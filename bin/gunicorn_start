#!/bin/bash

set -eo pipefail

ENV=$1

if [[ $ENV != "production" && $ENV != "staging" ]]
then
  echo '$ENV must be "production" or "staging"'
  exit 1
fi

NAME="openprescribing_$ENV"

# REPO_ROOT and APPS_ROOT match definitions in settings
REPO_ROOT=$(dirname $(dirname $0))
APPS_ROOT="$REPO_ROOT/openprescribing"

RUNDIR="$REPO_ROOT/run"
LOGDIR="$REPO_ROOT/logs"

# Create the run and logs directories if they don't exist
mkdir -p $RUNDIR
mkdir -p $LOGDIR

SOCKFILE="$RUNDIR/gunicorn.sock"
PIDFILE="$RUNDIR/gunicorn.pid"
LOGFILE="$LOGDIR/gunicorn-error.log"
ACCESS_LOGFILE="$LOGDIR/gunicorn-access.log"

# Export environment variables that depend on $ENV
export DJANGO_SETTINGS_MODULE="openprescribing.settings.$ENV"
export PYTHONPATH=$APPS_ROOT:$PYTHONPATH
export NEW_RELIC_CONFIG_FILE="$REPO_ROOT/newrelic.ini"
export NEW_RELIC_ENVIRONMENT=$ENV

# This is set here rather than with the rest of the config as we only want
# caching enabled for the web process not e.g. cron jobs or ad-hoc management
# commands. This is because if we're going to enable caching we also need to
# set SOURCE_COMMIT_ID and this can't be done in the static config file. The
# proper fix here is a single entry point script which all invocations of the
# app go through, but this avoids the problem for now.
export ENABLE_CACHING=True
export SOURCE_COMMIT_ID="$(git --git-dir="$REPO_ROOT/.git" rev-parse HEAD)"

echo "Starting $NAME"
echo "whoami: $(whoami)"
echo "ENV: $ENV"
echo "REPO_ROOT: $REPO_ROOT"
echo "APPS_ROOT: $APPS_ROOT"
echo "PYTHONPATH: $PYTHONPATH"

# Export each variable in the environment file, ignoring comments. Sourcing the
# file is insufficient as it sets the vars in the current environment but
# doesn't flag them for export to child processes.
export $(grep -v '^\s*#' "$REPO_ROOT/environment" | xargs)

# Activate the virtual environment
source "$VIRTUALENV_PATH/bin/activate"

# If we're running under systemd then it handles opening the socket and passes
# a file descriptor for the socket through to gunicorn (which knows how to
# handle this without any extra configuration).  While we're transitioning to
# this setup we check for the presence of the file descriptor environment
# variable and fall back to the traditional bind argument if it's not there.
if [[ -z "$LISTEN_FDS" ]]; then
  bind_arg="--bind=unix:$SOCKFILE"
else
  bind_arg=''
fi

# Start gunicorn via newrelic-admin
cmd="newrelic-admin run-program gunicorn openprescribing.wsgi:application \
  --name $NAME \
  $bind_arg \
  --pid=$PIDFILE \
  --workers $GUNICORN_NUM_WORKERS \
  --timeout $GUNICORN_TIMEOUT \
  --log-level=$GUNICORN_LOG_LEVEL \
  --log-file=$LOGFILE \
  --access-logfile=$ACCESS_LOGFILE"

if [[ ! -z $CHECK_CONFIG ]]; then
    cmd="$cmd --check-config"
fi

exec $cmd
